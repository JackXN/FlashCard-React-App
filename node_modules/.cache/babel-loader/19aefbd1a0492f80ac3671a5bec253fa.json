{"ast":null,"code":"/**\n * Defines the base URL for the API.\n * The default values is overridden by the `API_BASE_URL` environment variable.\n */\nconst API_BASE_URL = process.env.API_BASE_URL || \"http://localhost:5000\";\n/**\n * Defines the default headers for these functions to work with `json-server`\n */\n\nconst headers = new Headers();\nheaders.append(\"Content-Type\", \"application/json\");\n/**\n * Removes the `cards` property from the deck so it is not accidentally saved with the deck.\n *\n * This function is NOT exported because it is not needed outside of this file.\n *\n * @param deck\n *  the deck instance\n * @returns {*}\n *  a copy of the deck instance with the `cards` property removed.\n */\n\nfunction stripCards(deck) {\n  const {\n    cards,\n    ...deckWithoutCards\n  } = deck;\n  return deckWithoutCards;\n}\n/**\n * Fetch `json` from the specified URL and handle error status codes and ignore `AbortError`s\n *\n * This function is NOT exported because it is not needed outside of this file.\n *\n * @param url\n *  the url for the requst.\n * @param options\n *  any options for fetch\n * @returns {Promise<Error|any>}\n *  a promise that resolves to the `json` data or an error.\n *  If the response is not in the 200 - 399 range the promise is rejected.\n */\n\n\nasync function fetchJson(url, options) {\n  try {\n    const response = await fetch(url, options);\n\n    if (response.status < 200 || response.status > 399) {\n      throw new Error(`${response.status} - ${response.statusText}`);\n    }\n\n    return await response.json();\n  } catch (error) {\n    if (error.name !== \"AbortError\") {\n      throw error;\n    }\n  }\n}\n/**\n * Retrieves all existing decks.\n * @returns {Promise<[deck]>}\n *  a promise that resolves to a possibly empty array of decks saved in the database.\n */\n\n\nexport async function listDecks(signal) {\n  const url = `${API_BASE_URL}/decks?_embed=cards`;\n  return await fetchJson(url, {\n    signal\n  });\n}\n/**\n * Saves deck to the database (public/data/db.json).\n * There is no validation done on the deck object, any object will be saved.\n * @param deck\n *  the deck to save, which must not have an `id` property\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<deck>}\n *  a promise that resolves the saved deck, which will now have an `id` property.\n */\n\nexport async function createDeck(deck, signal) {\n  const url = `${API_BASE_URL}/decks`;\n  const options = {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(stripCards(deck)),\n    signal\n  };\n  return await fetchJson(url, options);\n}\n/**\n * Retrieves the deck with the specified `deckId`\n * @param deckId\n *  the `id` property matching the desired deck.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<any>}\n *  a promise that resolves to the saved deck.\n */\n\nexport async function readDeck(deckId, signal) {\n  const url = `${API_BASE_URL}/decks/${deckId}?_embed=cards`;\n  return await fetchJson(url, {\n    signal\n  });\n}\n/**\n * Updates an existing deck\n * @param updatedDeck\n *  the deck to save, which must have an `id` property.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the updated deck.\n */\n\nexport async function updateDeck(updatedDeck, signal) {\n  const url = `${API_BASE_URL}/decks/${updatedDeck.id}?_embed=cards`;\n  const options = {\n    method: \"PUT\",\n    headers,\n    body: JSON.stringify(stripCards(updatedDeck)),\n    signal\n  };\n  return await fetchJson(url, options);\n}\n/**\n * Deletes the deck with the specified `deckId`.\n * @param deckId\n *  the id of the deck to delete\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to an empty object.\n */\n\nexport async function deleteDeck(deckId, signal) {\n  const url = `${API_BASE_URL}/decks/${deckId}`;\n  const options = {\n    method: \"DELETE\",\n    signal\n  };\n  return await fetchJson(url, options);\n}\n/**\n * Retrieves all cards associated with the specified `deckId`.\n * @param deckId\n *  the id of the target deck\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to a possible empty array of cards.\n */\n\nexport async function listCards(deckId, signal) {\n  const url = `${API_BASE_URL}/cards?deckId=${deckId}`;\n  return await fetchJson(url, {\n    signal\n  });\n}\n/**\n * Creates a new card associated with the specified `deckId`.\n * There is no validation that there is an existing deck with the specified `deckId`.\n * @param deckId\n *  the id of the target deck\n * @param card\n *  the card to create, which must not have an `id` property\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the new card, which will have an `id` property.\n */\n\nexport async function createCard(deckId, card, signal) {\n  // There is a bug in json-server, if you post to /decks/:deckId/cards the associated deckId is a string\n  // and the card is not related to the deck because the data types of the ID's are different.\n  const url = `${API_BASE_URL}/cards`;\n  card.deckId = Number(deckId);\n  const options = {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(card),\n    signal\n  };\n  return await fetchJson(url, options);\n}\n/**\n * Retrieves the card with the specified `cardId`\n * @param cardId\n *  the id of the target\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the saved card.\n */\n\nexport async function readCard(cardId, signal) {\n  const url = `${API_BASE_URL}/cards/${cardId}`;\n  return await fetchJson(url, {\n    signal\n  });\n}\n/**\n * Updates an existing deck\n * @param updatedCard\n *  the card to save, which must have an `id` property.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the updated card.\n */\n\nexport async function updateCard(updatedCard, signal) {\n  const url = `${API_BASE_URL}/cards/${updatedCard.id}`;\n  const options = {\n    method: \"PUT\",\n    headers,\n    body: JSON.stringify(updatedCard)\n  };\n  return await fetchJson(url, options);\n}\n/**\n * Deletes the card with the specified `cardId`.\n * @param cardId\n *  the id of the card to delete\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to an empty object.\n */\n\nexport async function deleteCard(cardId, signal) {\n  const url = `${API_BASE_URL}/cards/${cardId}`;\n  const options = {\n    method: \"DELETE\",\n    signal\n  };\n  return await fetchJson(url, options);\n}","map":{"version":3,"sources":["/Users/jack/Desktop/Thinkful-mac-version/Thinkful/Projects/React/Project_Flashcards_Qualified_1/src/utils/api/index.js"],"names":["API_BASE_URL","process","env","headers","Headers","append","stripCards","deck","cards","deckWithoutCards","fetchJson","url","options","response","fetch","status","Error","statusText","json","error","name","listDecks","signal","createDeck","method","body","JSON","stringify","readDeck","deckId","updateDeck","updatedDeck","id","deleteDeck","listCards","createCard","card","Number","readCard","cardId","updateCard","updatedCard","deleteCard"],"mappings":"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","sourcesContent":["/**\n * Defines the base URL for the API.\n * The default values is overridden by the `API_BASE_URL` environment variable.\n */\nconst API_BASE_URL = process.env.API_BASE_URL || \"http://localhost:5000\";\n\n/**\n * Defines the default headers for these functions to work with `json-server`\n */\nconst headers = new Headers();\nheaders.append(\"Content-Type\", \"application/json\");\n\n/**\n * Removes the `cards` property from the deck so it is not accidentally saved with the deck.\n *\n * This function is NOT exported because it is not needed outside of this file.\n *\n * @param deck\n *  the deck instance\n * @returns {*}\n *  a copy of the deck instance with the `cards` property removed.\n */\nfunction stripCards(deck) {\n  const { cards, ...deckWithoutCards } = deck;\n  return deckWithoutCards;\n}\n\n/**\n * Fetch `json` from the specified URL and handle error status codes and ignore `AbortError`s\n *\n * This function is NOT exported because it is not needed outside of this file.\n *\n * @param url\n *  the url for the requst.\n * @param options\n *  any options for fetch\n * @returns {Promise<Error|any>}\n *  a promise that resolves to the `json` data or an error.\n *  If the response is not in the 200 - 399 range the promise is rejected.\n */\nasync function fetchJson(url, options) {\n\n\n  \n  try {\n    const response = await fetch(url, options);\n    if (response.status < 200 || response.status > 399) {\n      throw new Error(`${response.status} - ${response.statusText}`);\n    }\n    return await response.json();\n  } catch (error) {\n    if (error.name !== \"AbortError\") {\n      throw error;\n    }\n  }\n}\n\n/**\n * Retrieves all existing decks.\n * @returns {Promise<[deck]>}\n *  a promise that resolves to a possibly empty array of decks saved in the database.\n */\nexport async function listDecks(signal) {\n  const url = `${API_BASE_URL}/decks?_embed=cards`;\n  return await fetchJson(url, { signal });\n}\n\n/**\n * Saves deck to the database (public/data/db.json).\n * There is no validation done on the deck object, any object will be saved.\n * @param deck\n *  the deck to save, which must not have an `id` property\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<deck>}\n *  a promise that resolves the saved deck, which will now have an `id` property.\n */\nexport async function createDeck(deck, signal) {\n  const url = `${API_BASE_URL}/decks`;\n  const options = {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(stripCards(deck)),\n    signal,\n  };\n  return await fetchJson(url, options);\n}\n\n/**\n * Retrieves the deck with the specified `deckId`\n * @param deckId\n *  the `id` property matching the desired deck.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<any>}\n *  a promise that resolves to the saved deck.\n */\nexport async function readDeck(deckId, signal) {\n  const url = `${API_BASE_URL}/decks/${deckId}?_embed=cards`;\n  return await fetchJson(url, { signal });\n}\n\n/**\n * Updates an existing deck\n * @param updatedDeck\n *  the deck to save, which must have an `id` property.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the updated deck.\n */\nexport async function updateDeck(updatedDeck, signal) {\n  const url = `${API_BASE_URL}/decks/${updatedDeck.id}?_embed=cards`;\n  const options = {\n    method: \"PUT\",\n    headers,\n    body: JSON.stringify(stripCards(updatedDeck)),\n    signal,\n  };\n  return await fetchJson(url, options);\n}\n\n/**\n * Deletes the deck with the specified `deckId`.\n * @param deckId\n *  the id of the deck to delete\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to an empty object.\n */\nexport async function deleteDeck(deckId, signal) {\n  const url = `${API_BASE_URL}/decks/${deckId}`;\n  const options = { method: \"DELETE\", signal };\n  return await fetchJson(url, options);\n}\n\n/**\n * Retrieves all cards associated with the specified `deckId`.\n * @param deckId\n *  the id of the target deck\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to a possible empty array of cards.\n */\nexport async function listCards(deckId, signal) {\n  const url = `${API_BASE_URL}/cards?deckId=${deckId}`;\n  return await fetchJson(url, { signal });\n}\n\n/**\n * Creates a new card associated with the specified `deckId`.\n * There is no validation that there is an existing deck with the specified `deckId`.\n * @param deckId\n *  the id of the target deck\n * @param card\n *  the card to create, which must not have an `id` property\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the new card, which will have an `id` property.\n */\nexport async function createCard(deckId, card, signal) {\n  // There is a bug in json-server, if you post to /decks/:deckId/cards the associated deckId is a string\n  // and the card is not related to the deck because the data types of the ID's are different.\n  const url = `${API_BASE_URL}/cards`;\n  card.deckId = Number(deckId);\n  const options = {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(card),\n    signal,\n  };\n  return await fetchJson(url, options);\n}\n\n/**\n * Retrieves the card with the specified `cardId`\n * @param cardId\n *  the id of the target\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the saved card.\n */\nexport async function readCard(cardId, signal) {\n  const url = `${API_BASE_URL}/cards/${cardId}`;\n  return await fetchJson(url, { signal });\n}\n\n/**\n * Updates an existing deck\n * @param updatedCard\n *  the card to save, which must have an `id` property.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the updated card.\n */\nexport async function updateCard(updatedCard, signal) {\n  const url = `${API_BASE_URL}/cards/${updatedCard.id}`;\n  const options = {\n    method: \"PUT\",\n    headers,\n    body: JSON.stringify(updatedCard),\n  };\n  return await fetchJson(url, options);\n}\n\n/**\n * Deletes the card with the specified `cardId`.\n * @param cardId\n *  the id of the card to delete\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to an empty object.\n */\nexport async function deleteCard(cardId, signal) {\n  const url = `${API_BASE_URL}/cards/${cardId}`;\n  const options = { method: \"DELETE\", signal };\n  return await fetchJson(url, options);\n}\n"]},"metadata":{},"sourceType":"module"}